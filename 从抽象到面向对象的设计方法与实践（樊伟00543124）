《从抽象到面向对象的设计方法与实践》

	软件设计的现状和问题
	什么是软件设计中的抽象
	为什么需要面向对象进行设计
	如何开始面向对象设计
	面向对象实践
	如何提高抽象和设计能力
软件设计的现状和问题
	产品需求中的业务流程直接以过程化的形式体现在了软件设计中：导致软件实现与业务流程强相关。
	上层模块职责清晰，但模块内部和模块间的依赖和调用错综复杂
	为什么：模块的接口体现的是对一个过程的实现序列，而不是对象的抽象行为，限制了接口的适用目标和场景，作用关系长，耦合性强。结果：修改频繁，难于维护。
	更进一步的原因思考：没有从对象的角度来抽象和定义其通用的属性和行为，缺乏对元素和规律的抽象。
软件设计的现状和问题——逻辑视图到开发视图的抽象
什么是抽象
什么是抽象——案例1
	负载分担
	核心逻辑：选取负载较轻和较重的资源节点(Container.GetLightNode/GetHeavyNode)，均衡其负载
	行为：选取负载较轻和较重的资源节点
	新用户加入：为其选择负载较轻的资源节点(LogicIntf.AddUser,MemberPort.AddUser,LogicNode.AddUser)
	新资源节点加入、Up：(LogicIntf.AddMemberPort/SetMemberPortUp)
–	将负载较重资源节点中的（负载较重）子节点，搬迁到新资源节点上:(OffLoadToNewNode)
	资源节点不可用、Down：(LogicIntf.DelMemberPort/SetMemberPortDown)
–	将其中的（负载较重）子节点，搬迁到其它负载较轻的资源节点上:(OffLoadFromDownNode)
	静态对象：
	LogicIntf：一个资源池最上层对外体现的管理层接口
	MemberPort：资源节点，承载子资源节点
	LogicNode：子资源节点，承载最终的用户负载
	动态对象：资源节点容器、负载分担算法
	Container,DASL(Deviation Allowed Sorting List)
什么是抽象——案例1
什么是抽象——案例2
	单板类型和槽位的匹配
	核心逻辑：将匹配关系抽象出来，通过规律化的方式体现出来，将单板类型和槽位类型的变化因素，通过抽象数据类型和具体数据类型，以层次化的方法隔离开来，实现关系层面的稳定。
	动态对象：单板类型和槽位类型在不同层面上的匹配关系，及关系的承载形式(公式、数据表)
	静态对象：
	抽象单板类型、抽象槽位类型，以及它们的抽象数据特征和基本操作
	具体单板和槽位类型：承载更为具体、多变的板、槽类型信息，由抽象接口进行提取，参与到动态对象的关系运算中
如何进行抽象——框架、约束、逻辑域
框架：决定了是什么，要做什么。框架承载两个内容，即关系和元素
	从核心关系(系统目标）入手，对系统运行的内在逻辑进行抽象。
	识别支撑核心关系的逻辑元素，即静态对象，分析(考虑核心约束)其本质有哪些属性、行为。
	关系如何表达，动态对象如何将静态对象组织起来，进一步抽象(隔离非关键约束)逻辑元素，使其可以满足核心关系运行所需要的数据和行为要求。
约束：来自于不同场景，对元素和关系施加影响
	框架所支撑的系统运行在多个应用场景中，这个框架要能够适应各个场景中的区别和变化。
	不同场景中的约束关系，以层次化的方式（约束也有共性）对框架中的关系和元素施加影响，逐层提取共性的约束。
逻辑域：可从系统中拆分，具有特定目标的独立子系统、子功能
	系统整体表现出巨大的复杂性和无规律性，但其中的一个部分，通常具有特定的功能和规律。
	稳定抽象(Stable Abstractions Principle)：稳定的关系应该是抽象的，不稳定的关系应该是具体的。
如何进行抽象——约束案例
负载分担
	约束：主备控制板的行为和数据备份，主板的某些操作不能都在备板执行，如对系统公共资源的申请和分配，只能由主板完成，状态必须通过数据备份来完成，要求LogicIntf提供的API必须支撑对基础数据的原子操作(LogicIntf.AddLoigcNode不仅可以根据负载分担规则来添加新LogicNode,还需要在备板中支持将LogicNode加入到指定的MemberPort)
	单一职责和单一接口：相同职责归并到相同接口，什么是相同职责？
	AddLogicNode
	AddNewLogicNode：按负载分担原则来添加新LogicNode
	AddFixedLogicNode：将LogicNode添加到指定的MemberPort
	socket (int family, int type, int protocol)，
	Family:AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE、AF_KEY
	Type:SOCK_STREAM、SOCK_DGRAM、SOCK_SEQPACKET、SOCK_RAW
	Protocol:IPPROTO_TCP、IPPROTO_UDP、IPPROTO_SCTP

如何进行抽象——逻辑域案例
	负载分担功能包括两个部分：
	A：在管理层按照负载分担的逻辑，得到用户在资源节点负载分担的结果
	B：将用户负载分担的结果下发至转发层，实现用户流量和负载在资源节点间的搬迁
为什么需要面向对象进行设计
	在设计中，我们要提炼和把握的是过程中的核心关系
	关系依赖于参与一个个过程中的具体对象
	对象可以被进一步抽象，提取共性，以反映核心的逻辑关系
	而过程化设计方法中的函数所反映的是具体对象之间的操作关系，无法体现抽象对象的共性，因而无法实现对高层抽象逻辑的表达。
	在共性抽象的基础上，以继承和多态的方式来兼容具体差别
	继承和多态是面相对象的核心，也是实现各类抽象关系的基础
	面向对象设计，则是实现这一切的基础，也是实现合理逻辑域划分的基础
	良好的逻辑域划分，也是建立稳定、优秀测试逻辑的基础
面向对象设计——如何开始
	传统的过程化设计方法中，我们首先根据对流程的分析，考虑如何以过程/函数来组织和表达一个流程，然后定义支撑过程实现所需的数据结构
	面向对象设计，我们同样从流程分析入手，识别和提炼两个内容：
	核心逻辑(领域建模)：通常不一定能一次精准地把握到位，取决于领域经验和设计经验
	元素：具体元素和抽象元素，抽象元素和抽象关系的识别与定义是相辅相成、相互依存的
	在模拟业务流程时，不要以函数作为切入点，而是首先考虑这个流程需要以什么对象之间的合作来完成。
	在此基础上，为对象定义其所承载的两个关键内容：数据和行为
	进一步地分析流程，提取核心共性逻辑，考虑以什么样的方式来实现这个抽象逻辑：设计模式
	依据共性的核心，进一步对具体对象进行抽象，定义更通用的基类
	考虑流程中的场景约束，分析在哪个环节，以什么样的方法来引入这些约束和差别：继承和多态
面向对象实践经验
	对象的生命周期：过程化设计方法中，函数是主角，数据结构是配角，面向对象的设计方法中，对象是业务流程中的主角
	封装的程度：封装可以减少耦合，但过度封装带来的效率的降低
	单一职责和单一接口：场景越多，约束越多，纵向分层、横向统一
	消除重复：同样的事情只在一个地方做，识别逻辑和关系重复，依靠抽象和设计去消除重复，而不仅是函数复用。
	识别主要矛盾(约束)来定义和分解系统：核心决定因素是什么（节点负载、板槽特征）
如何提高抽象和设计能力
	培养和提炼对业务领域规律的感觉（多尝试一句话总结，以及如何在总结的基础上展开，进行层次化描述），从这个感觉入手来把握其中的关系和元素，从而结合具体的场景分析，进一步展开设计过程。案例：
	负载分担：寻找较轻和较重节点，平衡它们之间的负载。
	卡槽适配：以层次化的方式定义和匹配卡的特征与槽位特征，基于层次化关系进行匹配
	建立面向对象的思维习惯：
	以对象来组织和设计流程
	以数据和行为来构建对象
	熟悉设计模式和应用场景，学习别人的优秀设计，体会其分析和设计的思路、过程。
	熟练运用设计模式，但又不拘泥于现有模式，在设计过程中有所创新

