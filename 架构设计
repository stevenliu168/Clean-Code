依赖倒置原则（Dependency Inversion）
描述
软件（源代码层次的）依赖关系不应该根据业务分层，让上层组件依赖下层组件；而应该遵从以下原则：
	高层不应依赖于低层，二者都应该依赖于抽象。业务只看到抽象接口，而看不到实现细节。
	抽象不应该依赖于细节，细节应该依赖于抽象。

依赖：
在依赖倒置原则中，依赖指的不是实际的业务调用方向（控制流方向），而是特指（软件包之间真实的）源码依赖（source code dependency）。
这种源码依赖，指的是软件包中对其他软件包的引用，A依赖B，代表A的软件包中引用了B中的类名、变量名、函数名、数据结构等，常见的引用方式包括import，include，use等。
正是这种依赖关系的存在，导致了当B发生变化时，可能引发A的变化，并导致A无法脱离于B而存在和重用。

依赖倒置：
从实际业务调用方向来说，通常都是从高层逐级调用更下层的能力来完成真实业务，即业务的调用总是从高层逐级传递下来的。这个方向是客观现实，无法进行改变。
在传统的结构化设计中，软件代码的依赖关系往往遵从于这个方向，即高层模块include底层模块的头文件，并调用底层模块的函数。这样，其源码依赖关系与实际业务调用方向一致，是高层依赖于底层。这种依赖关系，往往会导致（更具价值的）高层模块无法脱离底层技术实现细节而存在，无法独立的构建和测试，也难以进行重用。
Robert C. Martin发现，软件包之间的依赖方向，是可以采用技术手段任意调整的。
如图，原本Application直接依赖于Service，而通过定义抽象接口，变成了Application和Service都依赖于接口Service和Service Factory。即依赖倒置原则一、高层不依赖于底层，二者都依赖于抽象。
更进一步，在代码打包时，应让接口归属于更高抽象层次的上层（如图：抽象接口Service和Service Factory都归属于更高抽象层次的Application，而非完成具体实现的Service）。因而从代码包依赖的角度，呈现为下层反过来依赖于上层。即依赖倒置原则二、抽象不依赖于具体实现，具体实现应该依赖于抽象。
通过这种依赖调整，软件的依赖方向与传统结构化设计的依赖方向相反，同时也与软件的控制流相反，因此称作依赖倒置。
Robert C. Martin认为，架构师的核心工作之一，就是确定不同部件间的依赖方向。并在Clean Architecture一书中给出了针对架构师的依赖倒置原则解读：
DIP: The Dependency Inversion Principle
The code that implements high-level policy should not depend on the code that implements low-level details. Rather, details should depend on policies.
依赖倒置原则：实现高层策略的代码不应该依赖于实现底层细节的代码，而应该反过来，让细节依赖于策略。（Clean Architecture——Robert C. Martin）
