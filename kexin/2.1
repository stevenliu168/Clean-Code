2.1.1	服务化/组件化原则（Service/Component）
	描述
根据产品业务诉求，合理的采用服务化、组件化架构，使产品具备灵活、按需组合的能力，以更好地适应为了业务、技术和环境等变化。

服务与组件的核心差异： 
	设计差异：服务与组件是从不同的出发点来分治系统的复杂度。
服务：以对外提供能力、单一业务职责为出发点。服务是从外部业务特征出发来进行服务划分的，重点关注的是每个服务对业务提供的独立单一的价值，从而体现为业务特征上的解耦，不同的服务往往代表不同的业务领域或不同的业务功能。
组件：以内部协作、重用为出发点。传统上组件划分不强调业务特征解耦，而是从内部实现和协作来进行划分，因此组件更像是能够组合起来完成业务功能的零件，而不严格强调独立的业务功能。当然从组件划分来说，完全可以借鉴服务划分的方法，从业务特征解耦的角度来划分，从而形成不同的业务组件。
	实现差异：服务与组件在实现技术上有较大的差异。
服务：服务强调的是运行态的隔离和服务的自治，不同的服务往往运行在不同的容器、虚机乃至物理机上，拥有相对独立的运行环境和技术栈，服务间除了接口以外，完全是隔离的，不太可能通过接口以外的路径进行跨服务访问或攻击。
组件：组件强调的是编译态的隔离，每个组件都是一个独立的二进制交付件，但通常很多组件是运行在同一个CPU、同一个OS乃至同一个框架的（当然组件也有跨系统情况），组件间的隔离性往往不如服务那么严格。

备注：组件化定义及相应要求：参见公司内部规范库中的《华为公司组件化定义V1.0》，链接为： http://w3.huawei.com/ipd/tsl/#!tsl_new/standard/standard.html?standardId=152499；服务化定义待发布。


	设计指导
1.	服务化/组件化都是一种架构选择，没有先进或落后的区别，产品需要根据自身特点和业务需求来权衡选择。
2.	服务化架构更适用于云化/云服务/IT类产品，相应产品建议重点分析和考虑。
3.	组件化架构更适用于嵌入式产品，相应产品建议重点分析和考虑。
2.1.2	分层设计原则（Layered）
	描述
系统分为多个层次，每个层次具有明确的功能定位，层次之间具有明确的、可信的依赖关系。

	设计指导
分层架构是运用最为广泛的架构模式，几乎每个软件系统都通过层（Layer）来隔离不同的关注点、业务复杂度或技术复杂度。在应用分层设计时，需要重点关注两个问题：
1.	分层的依据与原则：
	依据不同的抽象层次的不同关注点来分层：
在分层架构中，层次越高，越贴近业务概念，其抽象层次也越高；层次越低，越贴近具体实现，其抽象层次也越低。同时，不同层次的关注点也完全不同。如典型的ISO/OSI 7层模型，以及TCP/IP的4层模型，对于最上方的应用层，面向用户所需的具体业务抽象，如FTP关注的是文件传输的概念抽象；下方的传输层，如TCP/UDP，关注如何建立端到端的业务连接；在下方的网际层/网络层，关注的是数据本身的传输；最下方的网络接口层/数据链路层，则关注数据连接的真实实现。
 
	依据变化点隔离来分层：
分层时应针对不同的变化原因确定层次的边界，严禁层次之间互相干扰，或者至少将变化对各层带来的影响降到最低。例如数据库结构的修改自然会影响到基础设施层的数据模型以及领域层的领域模型，但当我们仅需要修改基础设施层中数据库访问的实现逻辑时，就不应该影响到领域层了。
2.	分层设计的协作方式：
	每个层次都实现对下层的屏蔽：
对于同样层次的部件/组件间，体现为同一抽象层次的协作（接口）关系。通过同抽象层次的协作，隐藏和封装其对下层的真实调用。如：Telnet的客户端和服务端，从业务上直接通过应用层的接口来协作，其真实的通过传输层、网络层、物理层的真实通讯过程完全被应用层接口屏蔽。
	每个层次实际上都通过对下层的调用实现所需的功能：
上层高抽象层次的业务，往往是需要调用其下层的功能来实现的。从业务逻辑上体现为上层调用下层。同时对于是否允许跨层调用，需要根据具体业务来权衡。
	上层不能直接依赖于下层：
由于在分层设计中上层需要调用下层的功能，所以很容易错误的实现为上层直接依赖于下层，这种方式会导致上层业务强依赖于下层的具体实现，导致上层高价值业务难以重用，以及下层技术难以替换和演进。
我们需要通过依赖倒置原则，解除上层对下层的依赖。以便实现：低层模块的细节实现可以独立变化，避免对高层模块产生污染；在编译时，高层模块可以独立于低层模块单独存在；对于高层模块而言，低层模块的实现可替换。
具体实现要点：
1、	高层不应依赖于低层，二者都应该依赖于抽象。即通过抽象接口实现层间调用。
2、	抽象不应该依赖于细节，细节应该依赖于抽象。即上层拥有该抽象接口，下层依赖于该接口。
 
2.1.3	接口抽象和隔离原则（Interface segregation）
	描述
通过抽象的接口来隐藏服务/组件的实现细节，接口设计应充分体现业务抽象，不与具体实现相关，服务/组件间只能通过接口进行交互，接口契约化、标准化，跨版本兼容；
应该将隶属于不同客户的接口，分离到不同的接口文件中，即客户软件不应依赖于不需要的接口。即通过接口实现不同客户间的隔离。

	设计指导
1.	接口定义应该采用抽象业务语义来清晰的表达业务概念，而不应包含具体的实现技术，以便可以自由的替换实现方案而无需修改接口。
2.	优先使用多个窄接口（即从客户使用的角度设计接口，将不同客户的需求分离为不同的接口，通过同一个服务/组件实现多个接口的方式来支持不同的客户）而非一个宽接口（即从实现的角度来设计接口，将某个服务/组件在当前系统中需同时满足的功能定义到一个接口，即使这些需求是来自于不同的客户，彼此也没有密切的关系）。
2.1.4	可替换性优先原则（Replicability first）
	描述
优先针对可替换性进行设计，而不是可重用性。
可重用性：是从部件（服务/组件）重用角度考虑，希望部件能在多个产品/场景重用，其本质是延长部件的生命周期。在可重用的思想下，通常要考虑如何支撑不同场景业务的差异化需求；同时在实现部件时，要考虑部件使用技术的长期稳定性和先进性。
可替换性：是从产品业务演进的角度考虑，希望所采用的部件能随着新技术的发展而快速演进，其本质是通过部件的快速替换来确保产品业务演进和技术先进性，从而延长产品的生命周期。在可替换性的思想下，重点考虑的是接口的设计（抽象，通用，易于替换等）。
随着软件技术的急速发展，在进行架构设计时，产品部件被新技术替代的速度加快，可替代性的重要性在很多情况下远远超过了可重用性。在设计时应优先针对可替换性，重点关注接口抽象、通用、易于替换，以及部件间的最小化共享依赖、部件的自治和冗余；在此基础上，再针对可重用性进行设计。而尽量避免为了重用现有部件，绑定在当前实现上，而牺牲可替换性。

	设计指导
1.	针对可替换部件（如开源/第三方部件，芯片驱动，中间件等），根据可替换性需求，可考虑其与其他部分的源码分离，或二进制分离。
2.	可替换部件与系统其他部分间的接口，建议从业务维度进行二次封装，避免系统依赖于可替换部分的接口定义和能力。
3.	应根据不同的业务场景和诉求，权衡考虑不同的替换性策略和技术。如基于开发期替换，可重点考虑代码分离和接口抽象和独立；基于交付期替换，可考虑二进制独立，二进制级的接口兼容性等；基于运行期替换，可考虑运行期的插件/组件动态加载卸载，微服务等技术。

2.1.5	最小修改原则（Minor modification）
	描述
业务应用层纵向划分优先原则，通过纵向划分，将大型的域分割为“变更孤岛”。避免业务应用层各部件间的复杂依赖关系。新增特性或问题修改涉及的组件/服务应该内聚，修改范围越少越好。

	设计指导
高内聚应包括从修改维度看的内聚，软件实体应尽量在不修改原有代码的情况下进行扩展。高内聚也有利于功能复用。

2.1.6	最小依赖原则（Minimum dependence）
	描述
部件对其他的部件/接口依赖越少，部件之间越容易形成契约化和解耦。如：系统支撑层里面包括最小运行环境支撑，以及其他工具类能力，需要分开。

	设计指导
部件间依赖包括启动依赖，运行依赖，接口调用等。复杂依赖会增加故障风险，影响运维的效率，即增加问题追查难度。

2.1.7	系统状态可视设计原则（System status visible）
	描述
系统各部件必须能够在开发和运行的各个执行阶段评估其状态和功能，并且在对应的界面呈现。

	设计指导
状态可视包括几个方面：
	依赖和调用关系可视：指在设计、代码实现、编译构建、以及运行期的部件依赖和调用的可视和一致性。
	各部件的功能可视：指功能在设计、代码、二进制交付、运行部件的映射。
	这里的呈现指开发状态向设计开发人员呈现，运行状态向运维人员呈现。
2.1.8	弹性伸缩原则（Elastic scaling）
	描述
通过业务处理逻辑与数据分离、状态外置等技术手段支撑系统处理能力的快速增加或减少。

	设计指导
系统扩容和缩容的处理方式有两种，一种是改变单机的处理能力，包括CPU、内存、存储等，称之为纵向伸缩；另一种是单机节点处理能力不变，通过增加节点的数量来改变系统的处理能力，称之为横向伸缩。
系统设计时建议采用横向伸缩，也就是首先做到。系统的业务模块支持业务处理逻辑和数据分离、数据（状态）外置，业务节点（含资源）按需快速增加或减少，从而实现系统业务处理能力的伸缩。
	优点：可采用低成本处理资源按需扩展系统性能, 系统扩展能力强, 可靠性高。
	缺点：系统架构整体复杂度提高, 需要自顶向下匹配领域业务特征进行架构设计。
