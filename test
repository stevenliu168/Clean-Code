3.1.1	服务实现独立性原则（Service implementation independence）
	描述
服务支持独立代码仓、独立开发、独立部署、独立运行、独立测试、独立版本原则。

	设计指导：
1.	按照领域驱动设计、数据驱动、和DFX功能服务化的方法对系统进行服务拆分，从架构角度实现功能的内聚和功能之间的解耦。
2.	为了阻止架构腐化，需要从工程角度长期保持服务之间的解耦，方法就是每个服务的开发活动在全流程独立，不和其他服务耦合。
3.	每个服务有独立的开发流水线，包括代码仓独立，没有共享的代码，如果需要共享代码，则以CBB的方式实现；每个服务的代码可以独立编辑、提交、单元测试；每个服务支持独立部署、运行，和简单的上下游测试桩配合，就可以输出有意义的业务结果，也就是服务的业务结果很容易“证伪”；服务支持独立版本，在云服务的场景下，支持独立上线。
3.1.2	服务数据去中心化原则（Service data decentralized）
	描述
每个服务拥有自己的数据表，服务不能直接访问其他服务的数据表，只能通过服务接口访问其他服务的数据。

	设计指导：
1.	系统实现服务拆分设计
2.	服务的数据也必须是解耦的，数据表之间不能有外键、存储过程等关联，一个服务也不能直接访问另一个服务的数据库，只能通过契约化的服务接口来访问。
3.	一般有两种实现方式：一种是服务的数据库实例隔离，数据之间没有任何公共操作，这种方式占用资源较多；另一种是服务共享同一个数据库，在Schema/用户层次实现数据隔离，会共享一些数据库级别的非业务操作，这种方式占用资源较少。
3.1.3	服务接口调用原则（Service only called by interface）
	描述
服务之间只能通过接口调用来通信，不能通过数据库共享、共享内存、未声明的方法等方式交换数据。

	设计指导：
1.	系统实现服务拆分设计。
2.	从领域的角度，初步整理服务应该提供的接口。
3.	把服务代入主要的业务场景，通过服务间的接口交互，能高效实现业务；如果发现不能实现，或者交互太多，或者出现所有业务都需要的上帝服务，就需要对服务的接口进行修改，甚至重新审视服务的拆分设计，直到高效实现业务。
4.	在实现业务的过程中，所有的数据交互，都应该通过显式声明的服务接口进行，服务接口包括API、消息等，但不允许通过数据库共享、共享内存、未声明的方法等其他方式。
3.1.4	智能服务端点和轻量级高性能通信原则（Smart endpoints and dumb pipes）
	描述
每个服务实例内置基本功能，如日志、度量、数据访问、输入校验、权限等，服务间的通信是轻量级高性能的。

	设计指导：
1.	每个服务都是一个独立完备的功能实体，避免为了完成业务功能，需要进行复杂的流程编排.
2.	除了完备的业务功能，每个服务还应该具有完备的非业务功能，包括日志、度量、数据访问、输入校验、权限等。一般来说，这些功能都是由服务框架提供。
3.	服务间的通信应该是轻量级高性能的，不要在服务通信中引入第三方实体实现负载均衡分发策略、失败重试、失败切换等机制。

3.1.5	服务灰度发布原则（Gray release of service）
	描述
服务支持按照用户组、流量比例把业务请求分发到不同版本的服务实例，实现灰度发布。

	设计指导：
1.	系统入口的负载均衡分发，支持按指定流量比例、用户组进行分发到后台。
2.	系统内部服务的负载均衡分发，一般只需要支持按流量比例分发。
3.	服务支持多版本共存，且负载均衡支持指定版本分发。

3.1.6	组件发布重用等价原则（Release/reuse Equivalence ）
	描述
软件的发布粒度和重用粒度相同。组件应通过发布和交付的方式提供给产品使用，必须提供组件粒度的版本号，版本管理和追溯能力。
注：此原则及后续组件原则中的“组件”代表公司组件化架构中所描述的组件，同时在大多数情况下，也可以代表更通用的系统部件划分原则。因此相应原则并不仅限于组件，采用其他部件划分的产品（如服务）也可以参考。


	设计指导：
1.	提供方以发布的形式提供重用组件，对组件进行版本管理和维护，同一个版本，代表唯一的组件。
2.	组件使用方直接使用组件，不支持源码级修改和裁剪，同时支持组件版本追溯和管理。

3.1.7	组件共同封闭原则（Common Closure）
	描述
组件内部应对同类变化共同封闭。从应对变化的角度来划分组件，对于某种原因（需求或问题），导致同时发生变化的部分应该封装到一个组件中，而将不因同一个原因发生变化的部分分离到不同的组件。

	设计指导：
这是最小修改原则的分解，应对某种原因的修改范围最小，目的是使得软件系统具备较好的稳定性。不过，这是尽力而为的原则，并和其他原则权衡，包括：
	评估变化发现的概率。
	评估封闭到一个组件的其他影响。

3.1.8	组件共同重用原则（Common Reuse）
	描述
组件对于使用者应该是共同重用的。从产品重用的角度来划分组件，对于使用组件的产品来说，组件中不含任何产品不会用到的部分。

	设计指导：
1.	要从使用者的角度而不是组件提供者的角度来划分组件。
2.	不要强迫使用者依赖到他不需要的东西。
3.1.9	组件无循环依赖原则（Acyclic Dependencies）
	描述
组件间禁止存在任何形式的代码级循环依赖（头文件包含，类名、方法名引用，数据结构引用等）。

	设计指导：
组件循环依赖会导致维护和重用的复杂，甚至影响编译。

3.1.10	组件稳定依赖原则（Stable Dependencies）
	描述
稳定性低的组件依赖于稳定性高的组件，避免稳定性高的组件依赖稳定性低的组件。同时希望易于修改，承载变化的组件，应该实现为稳定性低的组件。（稳定性可通过组件输入输出关系进行度量）。

	设计指导：
组件被依赖会导致对其修改会影响其他组件，因此被依赖越多，稳定性越高，越难于修改；被依赖越少，越容易修改。因此要让经常变化和修改的组件，依赖于其他组件，而不被其他组件依赖。
3.1.11	组件稳定抽象原则（Stable Abstractions）
	描述
稳定性应与抽象度一致，即抽象度高的部分应设计为高稳定性，并被抽象度低的部分依赖。

	设计指导：
1.	承载核心业务抽象概念的业务领域组件，其抽象程度比较高，也应该处于稳定度较高的层次，而承载技术实现细节的技术组件（包括IO、数据库、框架、中间件、硬件驱动等），以及承载用户具体业务用例和交互的UI组件，其抽象程度较低，应处于稳定度较低的层次。即根据之前的稳定依赖原则，技术组件以及UI组件都应该依赖于核心业务领域组件，以便实现核心业务领域的重用，并应对客户需求的快速变化及技术的快速演进。其依赖关系呈现为典型的Clean Architecture。
2.	组件间的依赖，应基于更加抽象和稳定的接口，而不依赖于具体的实现。
 
3.1.12	依赖倒置原则（Dependency Inversion）
	描述
软件（源代码层次的）依赖关系不应该根据业务分层，让上层组件依赖下层组件；而应该遵从以下原则：
	高层不应依赖于低层，二者都应该依赖于抽象。业务只看到抽象接口，而看不到实现细节。
	抽象不应该依赖于细节，细节应该依赖于抽象。
 

依赖：
在依赖倒置原则中，依赖指的不是实际的业务调用方向（控制流方向），而是特指（软件包之间真实的）源码依赖（source code dependency）。
这种源码依赖，指的是软件包中对其他软件包的引用，A依赖B，代表A的软件包中引用了B中的类名、变量名、函数名、数据结构等，常见的引用方式包括import，include，use等。
正是这种依赖关系的存在，导致了当B发生变化时，可能引发A的变化，并导致A无法脱离于B而存在和重用。

依赖倒置：
从实际业务调用方向来说，通常都是从高层逐级调用更下层的能力来完成真实业务，即业务的调用总是从高层逐级传递下来的。这个方向是客观现实，无法进行改变。
在传统的结构化设计中，软件代码的依赖关系往往遵从于这个方向，即高层模块include底层模块的头文件，并调用底层模块的函数。这样，其源码依赖关系与实际业务调用方向一致，是高层依赖于底层。这种依赖关系，往往会导致（更具价值的）高层模块无法脱离底层技术实现细节而存在，无法独立的构建和测试，也难以进行重用。
Robert C. Martin发现，软件包之间的依赖方向，是可以采用技术手段任意调整的。
如图，原本Application直接依赖于Service，而通过定义抽象接口，变成了Application和Service都依赖于接口Service和Service Factory。即依赖倒置原则一、高层不依赖于底层，二者都依赖于抽象。
更进一步，在代码打包时，应让接口归属于更高抽象层次的上层（如图：抽象接口Service和Service Factory都归属于更高抽象层次的Application，而非完成具体实现的Service）。因而从代码包依赖的角度，呈现为下层反过来依赖于上层。即依赖倒置原则二、抽象不依赖于具体实现，具体实现应该依赖于抽象。

 
通过这种依赖调整，软件的依赖方向与传统结构化设计的依赖方向相反，同时也与软件的控制流相反，因此称作依赖倒置。

 
Robert C. Martin认为，架构师的核心工作之一，就是确定不同部件间的依赖方向。并在Clean Architecture一书中给出了针对架构师的依赖倒置原则解读：
DIP: The Dependency Inversion Principle
The code that implements high-level policy should not depend on the code that implements low-level details. Rather, details should depend on policies.
依赖倒置原则：实现高层策略的代码不应该依赖于实现底层细节的代码，而应该反过来，让细节依赖于策略。（Clean Architecture——Robert C. Martin）


	设计指导：
1.	从架构的角度，依赖关系应从部件的抽象度来考虑，遵从低抽象度的部件依赖于高抽象度的部件，而非简单的上层依赖于下层。
2.	依赖倒置原则，从实现技术的角度，其本质为：1、制定抽象接口；2、确定接口归属权。
3.	对于接口归属权来说，由于大多数场景下使用方抽象层次更高，所以可以解读为：接口归属于使用方而非实现方。但在特定场景下，使用方与实现方处于同一个抽象层次，可以考虑将接口以独立软件包的形式呈现。
4.	依赖倒置的典型技术包括插件机制，依赖注入等。

3.1.13	服务/组件接口抽象、契约化和兼容原则（Service/Component interface abstraction, contractualization and backward compatibility）
	描述
服务/组件的接口需要具备完整的业务语义，隐藏内部的实现细节和管理细节，尤其是数据表的结构、集群结构、内部的逻辑流程等；服务/组件接口支持契约化和后向兼容，接口有明确版本管理。

	设计指导：
1.	服务/组件的接口是众多消费者使用的，所以接口不能完全按照某个消费者的要求来设计，应该从领域架构出发，设计出满足各种消费者、能被各类消费者共享的接口。
2.	推荐使用粗粒度的、具备完整业务语义的接口。
3.	接口用于隔离消费者和提供者，应该与提供者的内部逻辑解耦，避免服务/组件的内部逻辑变化导致接口发生变化，从而引起消费者逻辑的连锁变化。
4.	通常接口设计需要避免内部逻辑包括，数据库的表结构（举例：有服务共有n个数据库表，每个表提供增删改查共4个接口，共n*4个接口，导致接口频繁变化，而且性能很差）；集群接口（举例：有服务在接口中要指定服务实例所在的AZ、集群实例ID，导致消费者要随时知道服务的内部集群部署状况）；内部逻辑流程中的每个节点操作作为对外接口。
5.	接口一旦确定，就要保持稳定，也就是契约化，契约化的内容包括方法名、参数和返回值的用途、取值范围。
6.	如果接口发生了不兼容的变化，则要更新接口版本，新老接口版本共存一段时间，直到所有消费者切换到新版本。

3.1.14	逻辑与实现技术解耦原则（Decoupling of logic and implementation technology）
	描述
系统的业务逻辑实现不要绑定某个具体的技术，实现两者独立发展。实现技术可以做专题的跟踪和研究。架构设计上，需要为实现技术的替换做好准备。

	设计指导：
1.	逻辑与实现技术解耦是从可替换性考虑的，考虑技术发展变化，实现技术可以替代。
	新技术会出现，业务逻辑不绑定某个技术。
	原来放弃的技术，可能后续发展中占优势。
2.	解耦要考虑：
	技术栈分析，关注业界标准。
	业务逻辑保留扩展接口，考虑到替换工作量风险。

3.1.15	里氏替换原则（Liskov Substitutiion）
	描述
部件的替换，必须保证部件的使用方无需修改，原有功能完全正常。

	设计指导：
在考虑一个设计是否可以替换时，不能孤立的从实现者的角度来看，而需要从使用方的角度（即使用方的抽象化应用场景）来进行审视，只有在使用方完全无感知，无修改的情况下，原有功能完全正常，才认为部件是可替换的。

3.1.16	技术栈可替换原则（The technical stack can be replaced）
	描述
替换系统的技术栈，工作量应该为零或尽可能少。

	设计指导：
设计中采用技术中立标准化接口或适配器模式，可以简化后续开发语言、中间件、数据库等技术栈的变更工作。

3.1.17	单一职责原则（Single Responsibility）
	描述
系统部件划分，应考虑关注点分离，以便确保单一修改原因，只影响单一部件，而不导致多个部件因同一原因的联动修改。

	设计指导：
1.	单一职责原则不是指每个模块只做一件事。而是指一个模块只对一个actor负责，只有一个修改原因。
2.	单一职责原则的核心是将不同actor所依赖的代码分离到不同的文件/模块，以避免不同的团队因为不同的原因修改同一个文件/模块。

3.1.18	开闭原则（Open Closed）
	描述
系统应该能通过增加部件实现扩展，而不是对原有部件进行修改。

	设计指导：
实现开闭原则的要点：
•	应用单一职责原则，实现变化点分离。根据不同的修改原因，分离软件模块。
•	应用依赖倒置原则，确保正确的依赖方向。即易变的实现细节，依赖于抽象的业务策略和接口。

3.1.19	服务纵向拆分原则（Splitting services vertically）
	描述
从业务逻辑角度出发，对系统进行纵向拆分，目的是1）避免一个业务分散到多个服务，导致一个需求修改多个服务；2）避免一次业务串行调用多个服务导致性能下降。

	设计指导：
1.	从业务的角度拆分服务，保证每个服务都是一个单一完整的功能。
2.	尽量做到一个需求跨越尽量少的服务，需求更改时，受影响的服务少一些。
3.	业务请求尽可能并行调用多个服务，缩短服务调用的延时。


3.1.20	服务间最小单向依赖和显式声明原则（Minimize and One-way dependencies & explicit declarations）
	描述
服务之间的依赖越少越好，并且依赖关系显式化,依赖包括接口调用、环境变量共用、文件共用、表共用、配置共用等。

	设计指导：
1.	服务之间是解耦的，他们的数据交换只能通过接口方式，数量和频度都不宜过多，尤其要避免的是把接口调用和函数调用等同起来。
2.	服务之间可能会共享一些配置，如环境变量、文件等，这种情况要尽量避免。
3.	无论是接口调用还是共享配置，都要显式声明和呈现，不存在不受管理的依赖。
4.	服务间的依赖是单向的，避免形成双向依赖或者多个服务之间的环状依赖，导致这些服务耦合在一起，形成事实上的单体架构。

3.1.21	服务基础设施隔离性原则（Infrastructure isolation）
	描述
多个服务可以共享硬件、OS等基础设施，但不能互相影响。

	设计指导：
1.	服务和服务之间已经支持进程级/容器级的隔离；对于OS、虚拟机、物理机，不同服务可以分离部署，也可以共享部署。
2.	如果是共享部署，则应该隔离使用的资源和配置，包括CPU、内存、网络、环境变量等，避免服务之间互相影响。

3.1.22	系统公共模块隔离原则（Common modules isolation）
	描述
部件、资源，用户权限等都要进行隔离设计，以减少单部件失效带来的可信风险。减少因为公共资源的共享访问导致的程序之间的状态依赖。应该减少在系统组件（对象、流程、功能）之间共享计算资源、设备资源。 如果必要进行共享，应该进行权限隔离。

	设计指导：
1.	服务/组件拆分时，首先把系统的非功能公共模块分离出来，成为公共的服务/组件；至于与业务强相关的公共业务模块，只有在接口稳定的情况下才拆分为服务/组件。
2.	公共服务/组件实现多实例对等集群，达到高可用和水平伸缩。
3.	业务模块使用公共服务/组件时，做到资源隔离和权限隔离。

3.1.23	服务的状态可定义、可控制和可视设计原则（Service status be designed, controlled and visible）
	描述
服务在开发、运行阶段，所处的状态可定义、可设计、可评估、可控制，不会出现没有人知道的状态，所有的状态都有明确的、可控的迁移途径。在运行过程中，服务的状态支持远程呈现。

	设计指导：
1.	无论在开发态还是运行态，服务是个独立的业务实体，在每个阶段都应该是可以被信赖的。
2.	服务在开发、运行阶段，所处的状态可定义、可设计、可评估、可控制，不会出现没有人知道的状态，所有的状态都有明确的、可控的迁移途径。
3.	在运行过程中，服务的状态支持远程呈现。

3.1.24	服务接口定义和异常调用处理原则（How to define service interface and handle exceptions generated by calling interface）
	描述
服务接口的调用结果必须和声明一致，必须支持加密、认证、鉴权等安全防护手段，避免非法调用，确保数据的机密性和完整性。

调用服务接口时，必须针对接口异常、超时等做出处理，避免资源锁死、长时间占用或者不可知的状态。

	设计指导：
1.	服务接口的调用结果必须和声明一致。
2.	服务的接口必须支持加密、认证、鉴权等安全防护手段，避免非法调用，确保服务的数据的机密性、完整性。
3.	调用服务接口时，如果发现返回错误、异常格式消息、超时等，需要有相应的处理，消除不良影响，避免连锁异常反应，可能包括以下手段。
4.	失败重试：失败后，再重新调用一次，防止因为网络闪断造成的偶然问题。
5.	失败切换：失败多次后，重新调用另一个服务实例。
6.	异常消息抛弃：收到异常消息后，抛弃，避免继续把错误带到下个服务。
7.	降级：调用异常时，返回一个可接受的默认信息，让业务可以继续进行。

3.1.25	服务/组件调用支持调用链原则（Supporting call chains）
	描述
通过调用链跟踪业务流程经过的服务/组件和实例。

	设计指导：
1.	服务/组件应该在服务调用/应答的入口、出口处，打印调用链日志，信息至少包括本次业务请求ID、本次服务调用的序列号、调用方实例、被调用方实例、调用方法名。
2.	根据资源状况和使用者的需求，设计调用链展示的方式，如GUI界面或命令行。

3.1.26	业务逻辑与状态分离原则（Business logic and state separation）
	描述
服务状态、以及状态读写代码和业务逻辑代码解耦。

	设计指导：
1.	服务的状态指与会话相关、跟随会话变化的数据。
2.	服务状态提供专门的读写函数供业务逻辑调用，并实现服务状态持久化。
3.	业务逻辑代码的变化，不影响服务状态本身的的读、写、持久化等代码，反之也成立。

3.1.27	服务状态外置原则（Putting state data out from service）
	描述
服务的数据、会话保存在DB、Cache、对象存储等服务，实现服务进程无状态。

	设计指导：
1.	服务实现业务逻辑与数据、状态分离。
2.	服务的数据、会话状态保存在DB、Cache、对象存储等服务中。
3.	一个服务的每个实例都是对等的，业务请求可以由任何一个实例处理。
